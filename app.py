import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
import tkinter as tk
from tkinter import filedialog, messagebox, simpledialog, ttk
from imblearn.over_sampling import SMOTE

#define the class
class MalwareDetectionApp:

    #constructor definition (here self = this, master = root)
    def __init__(self, master):

        #set the main window title
        master.title("Malware Detection")

        # File selection button
        self.file_button = tk.Button(master, text="Select Dataset", command=self.load_file)
        #place the button in the main window and align it geometrically using pack geometry manager
        self.file_button.pack()

        # Label for file path
        self.file_label = tk.Label(master, text="")
        #place the label in the main window
        self.file_label.pack()

        # Button to handle missing data
        self.missing_data_button = tk.Button(master, text="Handle Missing Data", command=self.handle_missing_data, state=tk.DISABLED)
        #place the button in the window
        self.missing_data_button.pack()

        # Button to visualize data
        self.visualize_button = tk.Button(master, text="Visualize Data", command=self.visualize_data, state=tk.DISABLED)
        #place the button in the window
        self.visualize_button.pack()

        # Model selection dropdown
        #create a stringvar object which is a variable class and is used to store and retrieve the string values and assign the current value to 'mpdel_choice'
        self.model_choice = tk.StringVar()
        #set the default value of selection as svm
        self.model_choice.set("svm")
        #make a dropdown using themedtk and bind the combobox to 'model_choice' allowing the current selection to be stored in it
        self.model_dropdown = ttk.Combobox(master, textvariable=self.model_choice, values=["svm", "dt", "rf", "all"], state=tk.DISABLED)
        #place the combobox in the window
        self.model_dropdown.pack()

        # Button to run model
        self.run_button = tk.Button(master, text="Run Model", command=self.run_model, state=tk.DISABLED)
        #place the button in the window
        self.run_button.pack()

        # Text area to display results
        self.results_text = tk.Text(master, height=10, width=50)
        #place the text section in thw window
        self.results_text.pack()

        # Button to save results
        self.save_button = tk.Button(master, text="Save Results", command=self.save_results, state=tk.DISABLED)
        #place the button in the window
        self.save_button.pack()

        #initialize the required variables such as for the dataset, different models, and and a results list
        self.my_data = None
        self.svm_model = None
        self.dt_model = None
        self.rf_model = None
        self.results = []
        
    #function to select the dataset
    def load_file(self):
        #open a filedialog and return the file path selected as a string which is stored in 'file_path'
        file_path = filedialog.askopenfilename()
        #check if file path is not an empty string
        if file_path:
            #change the text value in 'file_label' to the file path
            self.file_label.config(text=f"Selected file: {file_path}")
            #resd the dataset
            self.my_data = pd.read_csv(file_path)
            #configure all the buttons from 'disabled' to 'normal'
            self.missing_data_button.config(state=tk.NORMAL)
            self.visualize_button.config(state=tk.NORMAL)
            self.model_dropdown.config(state=tk.NORMAL)
            self.run_button.config(state=tk.NORMAL)

    def handle_missing_data(self):
        #proceed only if you have a dataframe
        if self.my_data is not None:
            #find out the total number of missing values
            total_na = self.my_data.isnull().sum().sum()
            if total_na > 0:
                #open a dialog box to take action with the title 'input'
                action = simpledialog.askstring("Input", "Missing data detected. Choose an action (remove/impute):").strip().lower()
                if action == 'remove':
                    #drop all the rows containig missing values
                    self.my_data = self.my_data.dropna()
                elif action == 'impute':
                    #collect the names of all numeric valued columns
                    numeric_columns = self.my_data.select_dtypes(include=[np.number]).columns
                    #collect the names of all non numeric valued columns
                    non_numeric_columns = self.my_data.select_dtypes(exclude=[np.number]).columns
                    #replace the missing numeric values with the mean value of the column
                    self.my_data[numeric_columns] = self.my_data[numeric_columns].fillna(self.my_data[numeric_columns].mean())
                    #replace the missing non numeric values with the most frequently occuring value in that column
                    self.my_data[non_numeric_columns] = self.my_data[non_numeric_columns].apply(lambda col: col.fillna(col.mode()[0]))
                else:
                    messagebox.showerror("Error", "Invalid action. No changes made to missing data.")
            else:
                messagebox.showinfo("Info", "No missing data found.")

    
    def visualize_data(self):
        if self.my_data is not None:
            #plot a graph to show the count of all the labels present in the dataset
            sns.countplot(x='Label', data=self.my_data)
            plt.title('Distribution of Classification')
            plt.show()

    def run_model(self):
        if self.my_data is not None:
            #drop the column named label and store the remaining dataframe in x
            x = self.my_data.drop(["Label"], axis=1)
            #store the column named label in y
            y = self.my_data['Label']
            #split into train and test set
            x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=10)

            # Apply SMOTE to the training data
            smote = SMOTE(random_state=10)
            x_train_res, y_train_res = smote.fit_resample(x_train, y_train)
            #create a dictionary to store the accuracies of the trained model
            accuracies = {}
            #get the model name chosen by the user
            model_choice = self.model_choice.get()
            
            if model_choice in ['svm', 'all']:
                kernel = simpledialog.askstring("Input", "Enter kernel type for SVM (linear/poly):").strip().lower()
                self.svm_model = SVC(kernel=kernel)
                self.svm_model.fit(x_train_res, y_train_res)
                predictions_svm = self.svm_model.predict(x_test)
                acc_svm = accuracy_score(predictions_svm, y_test)
                self.results.append(f'SVM Accuracy: {acc_svm}')
                accuracies['SVM'] = acc_svm
            
            if model_choice in ['dt', 'all']:
                max_depth = int(simpledialog.askstring("Input", "Enter max depth for Decision Tree:").strip())
                self.dt_model = DecisionTreeClassifier(max_depth=max_depth)
                self.dt_model.fit(x_train_res, y_train_res)
                predictions_dt = self.dt_model.predict(x_test)
                acc_dt = accuracy_score(predictions_dt, y_test)
                self.results.append(f'Decision Tree Accuracy: {acc_dt}')
                accuracies['Decision Tree'] = acc_dt

            if model_choice in ['rf', 'all']:
                n_estimators = int(simpledialog.askstring("Input", "Enter number of trees for Random Forest:").strip())
                self.rf_model = RandomForestClassifier(n_estimators=n_estimators, random_state=10)
                self.rf_model.fit(x_train_res, y_train_res)
                predictions_rf = self.rf_model.predict(x_test)
                acc_rf = accuracy_score(predictions_rf, y_test)
                self.results.append(f'Random Forest Accuracy: {acc_rf}')
                accuracies['Random Forest'] = acc_rf

            #show all the results in the text area
            self.results_text.delete(1.0, tk.END)
            self.results_text.insert(tk.END, "\n\n".join(self.results))
            #enable the save button
            self.save_button.config(state=tk.NORMAL)

            #in case of all show the comparison graph
            if model_choice in ['all']:
                self.plot_accuracies(accuracies)

    #function to plot the accuracy graph
    def plot_accuracies(self, accuracies):
        models = list(accuracies.keys())
        accuracy_values = list(accuracies.values())
        
        plt.figure(figsize=(8, 6))
        plt.bar(models, accuracy_values, color=['blue', 'green', 'orange'])
        plt.xlabel('Model')
        plt.ylabel('Accuracy')
        plt.title('Comparison of Model Accuracies')
        plt.show()

    #function to save results
    def save_results(self):
        save_path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV files", ".csv"), ("All files", ".*")])
        if save_path:
            output = pd.DataFrame([{"Model": "SVM" if "SVM" in result else "Decision Tree" if "Decision Tree" in result else "Random Forest", "Result": result} for result in self.results])
            output.to_csv(save_path, index=False)
            messagebox.showinfo("Info", f"Results saved to {save_path}")


#initialize the new instance of tkinter main window and assign the reference of that to 'root'
root = tk.Tk()
#an instance of the class and the main window 'root' is passed as an argument to it and its reference is assigned to 'app'
app = MalwareDetectionApp(root)
#call the tkinter event loop which keeps the application running and waiting for user interaction until the main window is closed by the user
root.mainloop()
